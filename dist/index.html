<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wind Widget</title>
  <style>
    :root {
      --widget-bg: linear-gradient(145deg, #1a3a5c 0%, #0d1f33 100%);
      --text-primary: #ffffff;
      --text-secondary: rgba(255, 255, 255, 0.7);
      --text-tertiary: rgba(255, 255, 255, 0.5);
      --accent: #5ac8fa;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 24px;
      background: #000;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', system-ui, sans-serif;
      -webkit-font-smoothing: antialiased;
      padding: 24px;
    }

    /* iOS Small Widget: 155x155pt, 20px radius */
    .widget {
      width: 155px;
      height: 155px;
      background: var(--widget-bg);
      border-radius: 20px;
      padding: 12px;
      position: relative;
      overflow: hidden;
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
    }

    /* Directional wind particles */
    .wind-particles {
      position: absolute;
      inset: 0;
      overflow: hidden;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.6s ease;
    }

    .widget.loaded .wind-particles {
      opacity: 1;
    }

    .particle {
      position: absolute;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      height: 2px;
      border-radius: 1px;
    }

    /* Corner elements */
    .corner {
      position: absolute;
      z-index: 1;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    /* Top left - Wind label */
    .top-left {
      top: 12px;
      left: 12px;
    }

    .widget-icon {
      width: 12px;
      height: 12px;
      color: var(--accent);
    }

    .widget-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }

    /* Top right - Location */
    .top-right {
      top: 12px;
      right: 12px;
    }

    .location-icon {
      width: 10px;
      height: 10px;
      color: var(--text-tertiary);
    }

    .location-text {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-tertiary);
    }

    /* Bottom row - Speed and Direction */
    .bottom-left {
      bottom: 12px;
      left: 12px;
      align-items: center;
      gap: 2px;
      height: 28px;
    }

    .wind-speed {
      font-size: 15px;
      font-weight: 400;
      color: var(--text-primary);
    }

    .wind-unit {
      font-size: 11px;
      font-weight: 400;
      color: var(--text-tertiary);
    }

    .bottom-right {
      bottom: 12px;
      right: 12px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(8px);
      border-radius: 8px;
      padding: 6px 8px;
      height: 28px;
    }

    .direction-arrow {
      width: 14px;
      height: 14px;
      color: var(--text-primary);
      transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .direction-text {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-primary);
      min-width: 18px;
      text-align: center;
    }

    /* Loading skeleton */
    .skeleton {
      background: linear-gradient(
        90deg,
        rgba(255, 255, 255, 0.06) 0%,
        rgba(255, 255, 255, 0.12) 50%,
        rgba(255, 255, 255, 0.06) 100%
      );
      background-size: 200% 100%;
      animation: shimmer 1.5s ease-in-out infinite;
      border-radius: 4px;
    }

    @keyframes shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    .widget.loading .wind-speed,
    .widget.loading .direction-text,
    .widget.loading .location-text {
      opacity: 0.3;
    }

    /* Load animation */
    .widget.loaded .top-left {
      animation: fadeSlideIn 0.3s ease-out 0ms both;
    }

    .widget.loaded .top-right {
      animation: fadeSlideIn 0.3s ease-out 50ms both;
    }

    .widget.loaded .bottom-left {
      animation: fadeSlideIn 0.3s ease-out 100ms both;
    }

    .widget.loaded .bottom-right {
      animation: fadeSlideIn 0.3s ease-out 150ms both;
    }

    @keyframes fadeSlideIn {
      from {
        opacity: 0;
        transform: translateY(4px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ============================================
       LIQUID GLASS CONTROL PANEL
       ============================================ */
    .control-panel {
      width: 280px;
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 16px;
      padding: 16px;
      box-shadow:
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group:last-child {
      margin-bottom: 0;
    }

    .control-label {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .control-label span {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-tertiary);
    }

    .control-value {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-primary);
      min-width: 60px;
      text-align: right;
    }

    /* Slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: white;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      transition: transform 0.15s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    input[type="range"]::-webkit-slider-thumb:active {
      transform: scale(0.95);
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* Direction buttons */
    .direction-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 4px;
      width: 120px;
      margin: 0 auto;
    }

    .dir-btn {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      color: var(--text-tertiary);
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .dir-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      color: var(--text-primary);
    }

    .dir-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #000;
    }

    .dir-btn.center {
      background: transparent;
      border-color: transparent;
      cursor: default;
      font-size: 14px;
    }

    /* Mode indicator */
    .mode-indicator {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .mode-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: #34c759;
    }

    .mode-dot.manual {
      background: #ff9f0a;
    }

    .mode-text {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-tertiary);
    }

    .reset-btn {
      margin-left: auto;
      padding: 4px 8px;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 4px;
      color: var(--text-tertiary);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .reset-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div class="widget loading" id="windWidget">
    <div class="wind-particles" id="particles"></div>

    <!-- Top left: Wind label -->
    <div class="corner top-left">
      <svg class="widget-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"/>
      </svg>
      <span class="widget-title">Wind</span>
    </div>

    <!-- Top right: Location -->
    <div class="corner top-right">
      <svg class="location-icon" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/>
      </svg>
      <span class="location-text" id="locationText">Tokyo</span>
    </div>

    <!-- Bottom left: Speed -->
    <div class="corner bottom-left">
      <span class="wind-speed" id="windSpeed">--</span>
      <span class="wind-unit">km/h</span>
    </div>

    <!-- Bottom right: Direction badge -->
    <div class="corner bottom-right" id="direction">
      <svg class="direction-arrow" id="directionArrow" viewBox="0 0 24 24" fill="currentColor">
        <path d="M12 2L8 10h8L12 2z"/>
        <rect x="11" y="9" width="2" height="12" rx="1"/>
      </svg>
      <span class="direction-text" id="directionText">--</span>
    </div>
  </div>

  <!-- Liquid Glass Control Panel -->
  <div class="control-panel">
    <div class="mode-indicator">
      <div class="mode-dot" id="modeDot"></div>
      <span class="mode-text" id="modeText">Live data</span>
      <button class="reset-btn" id="resetBtn">Reset to Live</button>
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Speed</span>
        <span class="control-value" id="speedValue">12 km/h</span>
      </div>
      <input type="range" id="speedSlider" min="0" max="100" value="12">
    </div>

    <div class="control-group">
      <div class="control-label">
        <span>Direction</span>
        <span class="control-value" id="dirValue">N (0°)</span>
      </div>
      <div class="direction-grid">
        <button class="dir-btn" data-dir="315">NW</button>
        <button class="dir-btn" data-dir="0">N</button>
        <button class="dir-btn" data-dir="45">NE</button>
        <button class="dir-btn" data-dir="270">W</button>
        <button class="dir-btn center">●</button>
        <button class="dir-btn" data-dir="90">E</button>
        <button class="dir-btn" data-dir="225">SW</button>
        <button class="dir-btn" data-dir="180">S</button>
        <button class="dir-btn" data-dir="135">SE</button>
      </div>
    </div>
  </div>

  <script>
    const API_URL = 'https://api.open-meteo.com/v1/forecast';

    // State
    let isManualMode = false;
    let currentData = { windSpeed: 12, direction: 0, location: 'Tokyo' };
    let particles = null;

    // Cardinal direction from degrees
    function getCardinal(degrees) {
      const cardinals = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
      const index = Math.round(((degrees % 360) + 360) % 360 / 45) % 8;
      return cardinals[index];
    }

    // Get user's location via browser geolocation
    async function getUserLocation() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
          (err) => reject(err),
          { enableHighAccuracy: false, timeout: 10000 }
        );
      });
    }

    // Reverse geocode coordinates to city name using BigDataCloud (CORS-friendly)
    async function reverseGeocode(lat, lon) {
      try {
        const response = await fetch(
          `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${lat}&longitude=${lon}&localityLanguage=en`
        );
        const data = await response.json();
        // Try to get city or locality name
        return data.city
          || data.locality
          || data.principalSubdivision
          || 'My Location';
      } catch (err) {
        console.error('Reverse geocode failed:', err);
        return 'My Location';
      }
    }

    async function fetchWeather(lat, lon) {
      const params = new URLSearchParams({
        latitude: lat,
        longitude: lon,
        current: 'wind_speed_10m,wind_direction_10m',
        timezone: 'auto'
      });

      const response = await fetch(`${API_URL}?${params}`);
      const data = await response.json();

      return {
        windSpeed: Math.round(data.current.wind_speed_10m),
        direction: data.current.wind_direction_10m
      };
    }

    // Enhanced particle system - intensity communicates speed
    class WindParticles {
      constructor(container) {
        this.container = container;
        this.windSpeed = 10;
        this.direction = 0;
        this.running = false;
      }

      setWind(speed, direction) {
        this.windSpeed = speed;
        this.direction = direction;
      }

      // Scale properties based on wind speed
      getParticleProps() {
        const speed = this.windSpeed;

        // Length: 20px at 0 → 70px at 100 (longer streaks)
        const length = 20 + (speed / 100) * 50;

        // Duration: 2s at 0 → 0.4s at 100 (faster = higher wind)
        const duration = Math.max(0.4, 2 - (speed / 100) * 1.6);

        // Opacity: 0.3 at 0 → 0.85 at 100 (more visible)
        const opacity = 0.3 + (speed / 100) * 0.55;

        // Spawn rate: 200ms at 0 → 25ms at 100 (much denser)
        const spawnRate = Math.max(25, 200 - speed * 1.75);

        return { length, duration, opacity, spawnRate };
      }

      createParticle() {
        if (!this.running) return;

        const particle = document.createElement('div');
        particle.className = 'particle';

        const props = this.getParticleProps();
        const size = 155;
        const length = props.length + Math.random() * 20;

        const sourceDir = ((this.direction % 360) + 360) % 360;
        const travelDir = (sourceDir + 180) % 360;

        // Travel direction as unit vector (for actual diagonal movement)
        const travelRad = travelDir * Math.PI / 180;
        const travelDx = Math.sin(travelRad);   // positive = right
        const travelDy = -Math.cos(travelRad);  // positive = down (screen coords)

        // Streak rotation aligns with travel direction
        const streakRotation = (this.direction + 90) % 360;

        let startX, startY;

        // 8-direction entry points for proper diagonal handling
        if (sourceDir >= 337.5 || sourceDir < 22.5) {
          // N (0°): enter from top edge
          startX = Math.random() * size;
          startY = -length;
        } else if (sourceDir >= 22.5 && sourceDir < 67.5) {
          // NE (45°): enter from top-right corner area
          if (Math.random() < 0.5) {
            startX = size * 0.5 + Math.random() * size * 0.5;
            startY = -length;
          } else {
            startX = size + length;
            startY = Math.random() * size * 0.5;
          }
        } else if (sourceDir >= 67.5 && sourceDir < 112.5) {
          // E (90°): enter from right edge
          startX = size + length;
          startY = Math.random() * size;
        } else if (sourceDir >= 112.5 && sourceDir < 157.5) {
          // SE (135°): enter from bottom-right corner area
          if (Math.random() < 0.5) {
            startX = size + length;
            startY = size * 0.5 + Math.random() * size * 0.5;
          } else {
            startX = size * 0.5 + Math.random() * size * 0.5;
            startY = size + length;
          }
        } else if (sourceDir >= 157.5 && sourceDir < 202.5) {
          // S (180°): enter from bottom edge
          startX = Math.random() * size;
          startY = size + length;
        } else if (sourceDir >= 202.5 && sourceDir < 247.5) {
          // SW (225°): enter from bottom-left corner area
          if (Math.random() < 0.5) {
            startX = Math.random() * size * 0.5;
            startY = size + length;
          } else {
            startX = -length;
            startY = size * 0.5 + Math.random() * size * 0.5;
          }
        } else if (sourceDir >= 247.5 && sourceDir < 292.5) {
          // W (270°): enter from left edge
          startX = -length;
          startY = Math.random() * size;
        } else {
          // NW (315°): enter from top-left corner area
          if (Math.random() < 0.5) {
            startX = -length;
            startY = Math.random() * size * 0.5;
          } else {
            startX = Math.random() * size * 0.5;
            startY = -length;
          }
        }

        // End position follows actual travel angle (enables diagonal movement)
        const travelDist = size * 2 + length;
        const endX = startX + travelDx * travelDist;
        const endY = startY + travelDy * travelDist;

        particle.style.cssText = `
          left: ${startX}px;
          top: ${startY}px;
          width: ${length}px;
          transform: rotate(${streakRotation}deg);
        `;

        const peakOpacity = props.opacity + Math.random() * 0.1;
        particle.animate([
          { transform: `translate(0, 0) rotate(${streakRotation}deg)`, opacity: 0 },
          { transform: `translate(${(endX - startX) * 0.1}px, ${(endY - startY) * 0.1}px) rotate(${streakRotation}deg)`, opacity: peakOpacity, offset: 0.1 },
          { transform: `translate(${endX - startX}px, ${endY - startY}px) rotate(${streakRotation}deg)`, opacity: 0 }
        ], {
          duration: props.duration * 1000,
          easing: 'linear'
        }).onfinish = () => particle.remove();

        this.container.appendChild(particle);
      }

      start() {
        this.running = true;
        const spawn = () => {
          if (!this.running) return;
          const props = this.getParticleProps();
          this.createParticle();
          setTimeout(spawn, props.spawnRate + Math.random() * 25);
        };
        spawn();
      }

      stop() {
        this.running = false;
      }
    }

    // Update widget display
    function updateWidget(speed, direction, location = currentData.location) {
      currentData = { windSpeed: speed, direction, location };

      document.getElementById('windSpeed').textContent = speed;
      document.getElementById('directionText').textContent = getCardinal(direction);
      document.getElementById('directionArrow').style.transform = `rotate(${direction + 180}deg)`;
      document.getElementById('locationText').textContent = location;

      if (particles) {
        particles.setWind(speed, direction);
      }

      // Update control panel
      document.getElementById('speedSlider').value = speed;
      document.getElementById('speedValue').textContent = `${speed} km/h`;
      document.getElementById('dirValue').textContent = `${getCardinal(direction)} (${Math.round(direction)}°)`;

      // Update active direction button
      document.querySelectorAll('.dir-btn').forEach(btn => {
        const btnDir = parseInt(btn.dataset.dir);
        btn.classList.toggle('active', btnDir === Math.round(direction / 45) * 45 % 360);
      });
    }

    function setManualMode(manual) {
      isManualMode = manual;
      const dot = document.getElementById('modeDot');
      const text = document.getElementById('modeText');

      if (manual) {
        dot.classList.add('manual');
        text.textContent = 'Manual control';
      } else {
        dot.classList.remove('manual');
        text.textContent = 'Live data';
      }
    }

    // Control panel handlers
    function setupControls() {
      // Speed slider
      const speedSlider = document.getElementById('speedSlider');
      speedSlider.addEventListener('input', (e) => {
        setManualMode(true);
        updateWidget(parseInt(e.target.value), currentData.direction);
      });

      // Direction buttons
      document.querySelectorAll('.dir-btn[data-dir]').forEach(btn => {
        btn.addEventListener('click', () => {
          setManualMode(true);
          updateWidget(currentData.windSpeed, parseInt(btn.dataset.dir));
        });
      });

      // Reset button
      document.getElementById('resetBtn').addEventListener('click', async () => {
        setManualMode(false);
        await refreshLiveData();
      });
    }

    // Fetch and update live data
    async function refreshLiveData() {
      if (isManualMode) return;

      try {
        const coords = currentData.coords || { lat: 35.68, lon: 139.69 };
        const data = await fetchWeather(coords.lat, coords.lon);
        updateWidget(data.windSpeed, data.direction, currentData.location);
      } catch (err) {
        console.error('Weather fetch failed:', err);
      }
    }

    // Initialize
    async function init() {
      const widget = document.getElementById('windWidget');
      particles = new WindParticles(document.getElementById('particles'));

      setupControls();

      let coords, locationName;

      // Try to get user's location, fall back to Tokyo
      try {
        coords = await getUserLocation();
        locationName = await reverseGeocode(coords.lat, coords.lon);
      } catch (err) {
        console.log('Location access denied, using Tokyo');
        coords = { lat: 35.68, lon: 139.69 };
        locationName = 'Tokyo';
      }

      // Store for refresh
      currentData.coords = coords;

      try {
        const data = await fetchWeather(coords.lat, coords.lon);

        widget.classList.remove('loading');
        widget.classList.add('loaded');

        particles.start();
        updateWidget(data.windSpeed, data.direction, locationName);

        // Refresh every 5 minutes (if not in manual mode)
        setInterval(refreshLiveData, 5 * 60 * 1000);

      } catch (err) {
        console.error('Weather fetch failed:', err);
        widget.classList.remove('loading');
        widget.classList.add('loaded');
        particles.start();
        updateWidget(12, 0, locationName);
      }
    }

    init();
  </script>
</body>
</html>
